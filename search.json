[{"title":"docker使用","url":"/2019/01/04/docker使用/","content":"\n# docker\n<!-- more -->\nDocker 是一个开源的应用容器引擎。\n\n![image-20181202173805932](assets/image-20181202173805932-3743485.png)\n\n\n\n## 特点\n\n- 环境一次安装，到处运行\n\n我们可以把配置好的环境制作成一个镜像，这个镜像就可以在所有安装了 Docker 的机器上直接运行。当我们需要为几台、几十台甚至几百台服务器安装环境时，我们只需要制作一个镜像，然后所有服务器就可以使用这个镜像启动服务了。\n\n\n\n- 与虚拟机的关系\n\nDocker 是`容器技术`，和虚拟机非常像，都可以在主机上隔离出多个独立的子系统，它们最大的区别在于虚拟机是从主机中完全隔离出一个系统来，而容器技术和主机是共享系统内核的。\n\n\n\n![image-20181203085309186](assets/image-20181203085309186-3798389.png)\n\n\n\n\n\n由于 Docker 与主机共享内核，所以有以下优势：\n\n1、速度更快\n\n​\tDocker不停地给大家宣传，\"虚拟机需要数分钟启动，而Docker容器只需要50毫秒\"。\n\n2、更加轻量\n\n​\t虚拟机中每个都是一套独立的系统，这就使得每个虚拟机都非常大，而 Docker 使用了分层的技术，不同的镜像之间可以同享相同的层，这使得容器尺寸很小。\n\n3、更节省资源\n\n​\t启动一个虚拟机，就要启动它内部的操作系统，这非常消耗资源，一台电脑上同时开启3~10个虚拟机电脑就已经完全跑不动了。\n\n​\t而 Docker 是共享主机内核，所以启动一个 Docker 就和启动一个普通的程序一样，所以我们可以同时在电脑上开启上千个 Docker 容器。\n\n\n\n## Docker 化\n\n有了 Docker 之后，我们就可以将我们的程序 Docker 化。\n\nDocker 化就是指将开发的系统制作成一个镜像，当要要新的机器上部署该项目时，只需要拉取镜像然后就可以直接创建容器来运行了，这样就省了重新安装运行环境的步骤了（在一台新的机器上搭建运行环境是非常麻烦的事情）。\n\n\n\n\n\n## 安装\n\nDocker 可以安装、运行在常见的 Linux 系统上，而对于 Windows 和 Mac 系统也有办法安装上。\n\nWindows：如果是 Windows10专业版，可以直接安装，如果是老的版本需要安装Docker虚拟机。\n\n安装之后，可以在命令行中执行 `docker` 指令：\n\n![image-20181202190931446](assets/image-20181202190931446-3748971.png)\n\n\n\n\n\n\n\n# 使用 Docker\n\n\n\n## 几个概念\n\n镜像（image）：已经打包好的 Docker 应用，有点类似于一个程序的安装包。\n\n镜像仓库：存储镜像的服务器。\n\n容器：有了镜像我们就可以创建容器了，容器就是运行着的镜像，一个镜像可以同时创建多个容器，容器之间的隔离的。\n\n![image-20181203085625272](assets/image-20181203085625272-3798585.png)\n\n\n\n## 常用指令\n\n\n\n| 指令                        | 说明                                 |\n| --------------------------- | ------------------------------------ |\n| docker images               | 查看已下载的镜像                     |\n| docker rmi 镜像名称:标签名  | 删除已下载的镜像                     |\n| docker search 镜像          | 从官方仓库（hub.docker.com）查找镜像 |\n| docker pull 镜像名称:标签名 | 标签名默认是 latest，代表最新版本。  |\n| docker run                  | 创建容器                             |\n| docker ps                   | 列出运行中的容器（运行中）           |\n| docker ps -a                | 列出未运行的容器                     |\n| docker rm 容器名称          | 删除停止的容器                       |\n| docker rm -f 容器名称       | 删除运行中的容器                     |\n| docker start 容器名称       | 启动容器                             |\n| docker stop 容器名称        | 停止容器                             |\n| docker restart 容器名称     | 重启容器                             |\n| docker exec                 | 执行容器中的指令                     |\n\n\n\n## 创建容器\n\n下载了镜像之后，我们就可以通过镜像来创建容器，创建容器时常用的参数是：\n\n~~~\ndocker run --name 容器名称 -d -p 主机端口:容器内端口 -e 环境变量 --link 其它容器名:容器中别名 镜像名称:标签名\n~~~\n\n参数说明：\n\n--name：指定容器名称\n\n-d：容器在后台运行\n\n-p：绑定端口号，容器内部的端口号无法在外部访问，必须经过绑定之后才可以访问\n\n--link：连接其它容器，当要访问其它容器中的内容时，需要先链接才可以使用\n\n-e：设置容器中的环境变量\n\n\n\n示例：创建一个 MySQL 容器，密码是123123，绑定本地 33306 端口到容器中 3306 端口：\n\n~~~\ndocker run --name mysql001 -d -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24\n~~~\n\n说明：MYSQL_ROOT_PASSWORD 环境变量用来设置这个容器中 MySQL 的密码\n\n\n\n创建之后，会启动这个容器，如果启动成功，就可以使用 `docker ps` 指令查看到：\n\n![image-20181202200118787](assets/image-20181202200118787-3752078.png)\n\n启动之后，这个容器内部就运行了 MySQL 服务器，在容器内部监听的是 3306 端口，我们已经将这个端口绑定到了主机的 33306 端口上，所以我们在主机上可以使用 33306 端口连接：\n\n![image-20181202200256983](assets/image-20181202200256983-3752177.png)\n\n## 进入容器\n\n有时我们需要进入到一个容器内部去操作这个容器，这时我们可以使用 `docker exec` 指令来实现。\n\ndocker exec 指令可以执行一个运行着的容器中的命令：\n\n~~~\ndocker exec -it 容器名称 命令\n~~~\n\n我们可以通过执行 `bash` 指令进入容器：\n\n~~~\ndocker exec -it mysql001 bash\n~~~\n\n或者\n\n~~~\ndocker exec -it mysql001 /bin/sh\n~~~\n\n-it：以实时交互的形式运行（和 -d 正好相反）\n\n\n\n执行之后就进入到了容器中，然后我们输入的命令是在容器中执行的\n\n![image-20181202200656835](assets/image-20181202200656835-3752416.png)\n\n\n\n执行 `exit` 指令可以退出容器。\n\n\n\n## 链接容器\n\nDocker 推荐我们一个容器中只运行一个主要的应用程序，比如，我们要运行一个 PHP + MySQL 的程序，那么我们应该把 PHP 和 MySQL 放到两个容器中：\n\n![image-20181202201722070](assets/image-20181202201722070-3753042.png)\n\n默认情况下，容器之间是不能直接通信的，如果要通信必须在创建 PHP 容器时使用 `--link` 参数建立和 MySQL 容器的链接：\n\n![image-20181202201858964](assets/image-20181202201858964-3753139.png)\n\n建立连接的参数说明：\n\n~~~\n--link 要连接的容器的名称 : 别名\n~~~\n\n在容器中可以使用别名来访问连接的容器。\n\n\n\n比如，我们现在运行了一个叫做 `mysql001` 的容器，现在我们要创建一个 PHP 容器并和 MySQL 容器建立链接，指令应该是：\n\n创建一个 PHP 容器，并且设置和 mysql001 容器建立连接，在 PHP 容器中连接的别名是 mysql\n\n~~~\ndocker run --name php001 -d --link mysql001:mysql            php\n~~~\n\n创建了链接之后，就可以在容器中使用别名来通信了：\n\n~~~php\n// 连接 mysql001 容器中的 MySQL 服务器\n$pdo = new PDO('mysql:host=mysql:3306;dbname=xxx', 'root', '123123')\n~~~\n\n\n\n扩展：我们可以同时添加多个 --link 来同时连接多个容器，比如同时连接mysq001和redis001两个容器：\n\n~~~\ndocker run --name php001 -d --link mysql001:mysql --link redis001:redis php\n~~~\n\n\n\n\n\n\n\n示例：安装 wordpress（一个开源的使用 PHP+MYQS 开发的内容管理系统 ）\n\n~~~\ndocker run --name wordpress --link mysql001:mysql -p 8080:80 -d wordpress\n~~~\n\n创建 wordpress 容器时，发现本地没有镜像就会自动下载最新的镜像，下载完之后就创建了容器，然后我们就可以在浏览器中访问 8080 端口：\n\n![image-20181202205110002](assets/image-20181202205110002-3755070.png)\n\n这样，我们就使用部署 wordpress 到我们的电脑上了。\n\n\n\n\n\n## 挂载硬盘\n\n问题一、数据是保存在容器里的，如果容器删除了数据也就删除了。\n\n问题二、每次要修改容器时，必须要进入到容器中去修改，比如要修改my.cnf。\n\n\n\n为了能够保存（持久化）数据以及共享容器间的数据，Docker 提出了 Volume 的概念。\n\n可以使用 `-v` 这个参数，将容器中的一个目录或者文件 和主机上的目录和文件进行绑定，绑定之后，修改主机上的这个文件就相当于修改了容器中的文件，删除容器之后，绑定的目录和文件还在主机（不会被删除）。\n\n\n\n为了实现主机和容器之间的数据共享，我们可以在创建容器时添加 `-v` 参数：\n\n~~~\ndocker run ... -v 主机目录:容器中的目录 ...\n~~~\n\n示例：创建 mysql 容器并将数据目录挂载到主机：\n\n~~~\ndocker run --name mysql002 -d -v /Users/wyl/Works/code/docker-volume-data/testmysql:/var/lib/mysql -p 33307:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24\n~~~\n\n\n\n示例：启动一个 Nginx 服务器并将 nginx 的主目录搭载到主机上\n\n1、下载 nginx\n\n~~~\ndocker pull nginx:1.15.6-alpine\n~~~\n\n2、到容器中查看网站根目录的路径\n\n~~~\ndocker run --name testnginx -d nginx:1.15.6-alpine   ## 创建容器\ndocker exec -it testnginx /bin/sh                    ## 进入容器\n~~~\n\n在容器中使用 vi 编辑器查看配置文件：\n\n~~~\nvi /etc/nginx/conf.d/default.conf\n~~~\n\n查看网站根目录是 `usr/share/nginx/html`。\n\n删除该容器\n\n~~~\ndocker rm -f testnginx\n~~~\n\n3、创建 nginx 容器并将 `/usr/share/nginx/html` 挂载到本地\n\n~~~\ndocker run --name nginx001 -d -p 30080:80 -v 本地目录:/usr/share/nginx/html nginx.1.15.6-alpine\n~~~\n\n\n\n\n\n## 复制文件\n\n我们可以使用 `docker cp` 指令向容器中复制文件，或者从容器中复制文件到主机。\n\n\n\n~~~\ndocker cp 源目录  目标目录\n~~~\n\n\n\n- 复制主机文件到容器\n\n~~~\ndocker cp C:/my.cnf mysql001:/etc/mysql/my.cnf\n~~~\n\n\n\n- 从容器复制文件到主机\n\n~~~\ndocker cp  mysql001:/etc/mysql/my.cnf C:/my.cnf\n~~~\n\n\n\n# 综合案例、使用 Docker 搭建 LNMP 环境\n\n我们平时在做开发时，为了简单、方便我们常用以下开发环境：\n\n1、WAMP\n\n2、Visual AMP\\NMP\n\n3、PHP 内置 WEB 服务器，如 `php -S localhost:9999 -t` 还有 Laravel 中的 `php artisan serve --port 8001` 。\n\n以上这三种只适用于开发时使用，在真正的线上环境我们需要安装更加稳定并且能够支撑高并发的运行环境，目前 PHP 的生产环境最常用的就是 `LNMP`。\n\nLNMP：Linux + Nginx + MySQL + PHP\n\n\n\n## Nginx\n\nNginx 是目前最流行的高性能、高并发的开源、免费的 WEB 服务器，俄国斯的开发。\n\n![image-20181203100116793](assets/image-20181203100116793-3802476.png)\n\nNginx 使用 Linux 中最流行的 `epoll` 做为事件处理机制，并且 Nginx 在运行时只消耗极少的系统资源，所以可以轻松实现上万的并发请求，Nginx 除了可以做为 WEB 服务器之外，还可以做为Email、反向代理、负载均衡、流媒体等服务器。\n\nNginx 和其它脚本语言（如PHP）一起工作时一般使用 FastCGI 机制。\n\n\n\n## 方案\n\n方案一、一个容器中同时 nginx php-mpm \n\n​\t好处：简单、方便\n\n​\t缺点：不利于每个软件的横向扩展\n\n方案二、把 nginx、php-fpm、MySQL 分别放到三个容器中\n\n​\t好处：有利于单独扩展每个系统\n\n​\t缺点：部署相对复杂\n\n\n\n\n\n## LNMP 模型图\n\n创建三个容器：Nginx、PHP-FPM、MySQL，它们之间的关系是：\n\n（说明：图中端口可以任意修改）\n\n![image-20181203100531441](assets/image-20181203100531441-3802731.png)\n\n\n\n总结：Nginx 负载处理静态文件，如果用户访问的是 PHP 文件，就转发给 PHP 服务器的9000来处理，PHP服务器处理完之后，把结果返回给 nginx,然后nginx再返回给前端。\n\n\n\n1、下载镜像\n\n下载 nginx 镜像（alpine版的更小）\n\n~~~\ndocker pull nginx:1.15-7-alpine\n~~~\n\n下载 MySQL 镜像\n\n~~~\ndocker pull mysql:5.27.24\n~~~\n\n下载 PHP-FPM 镜像\n\n~~~\ndocker pull php:7.2-fpm-alpine\n~~~\n\n\n\n![image-20181203104220103](assets/image-20181203104220103-3804940.png)\n\n\n\n2、创建容器\n\n我们创建三个容器 Nginx、PHP-FPM、MySQL，这里需要注意的是它们创建的顺序：\n\nMySQL => PHP-FPM => Nginx\n\n创建 MySQL 容器\n\n~~~\ndocker run --name mysql001 -d -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24\n~~~\n\n创建 php 容器\n\n~~~\ndocker run --name phpfpm7.2 -d --link mysql001:mysql php:7.2-fpm-alpine\n~~~\n\n创建 nginx 容器\n\n~~~\ndocker run --name nginx -d -p 8988:80 --link phpfpm7.2:php nginx:1.15.7-alpine\n~~~\n\n\n\n3、配置 Nginx\n\nNginx 只能对静态文件（html，css，js，图片等）进行处理，无法处理动态文件（php、python等），我们需要配置 nginx 将动态脚本转发给 PHP 服务器。\n\na. 进入 nginx 容器\n\n~~~\ndocker exec -it nginx /bin/sh\n~~~\n\n\n\nb、查找配置文件位置\n\n~~~\nfind / -name nginx.conf\n~~~\n\n\n\nc、修改 Nginx 的配置文件\n\n/etc/nginx/conf.d/default.conf\n\n~~~\nserver {\n    ...\n\n    location / {\n        root   /usr/share/nginx/html;    # 网站根目录\n        index  index.html index.htm;\n    }\n\n    ...\n    \n    location ~ \\.php$ { \n        fastcgi_pass   php:9000;         # 转发到 PHP 服务器的地址,PHP是容器的别名\n        fastcgi_index  index.php;        \n        fastcgi_param  SCRIPT_FILENAME  /php$fastcgi_script_name;  # 转发的文件名\n        include        fastcgi_params;                                \n    }   \n    \n    ...\n}\n~~~\n\n说明：\n\n$fastcgi_script_name ：代表当前访问的文件名，比如，如果访问的是 localhost/1.php ，那么这一项的值就是 1.php\n\n\n\nd、退出 nginx 容器并重新启该容器\n\n因为我们修改了 nginx 的配置文件，所以我们需要重启服务器\n\n~~~\ndocker restart nginx\n~~~\n\n\n\ne、进入 phpfpm 容器创建 /php 目录\n\n在 nginx 中我们配置了，当遇到 PHP 脚本时，就转发 `/php$fastcgi_script_name;` 这个路径到 php 容器，所以PHP会到它的 `/php` 目录下去查找，所以我们需要进入 PHP 创建中并创建这个目录。\n\n进入PHP容器\n\n~~~\ndocker exec -it phpfpm7.2 /bin/sh\n~~~\n\n进入容器之后，创建目录\n\n~~~\nmkdir /php\n~~~\n\n然后我们就可以在 /php 目录中创建  php 脚本了，这些脚本就可以通过浏览器运行访问了。\n\n\n\nNginx 运行PHP的流程：\n\n![image-20181203115802443](assets/image-20181203115802443-3809482.png)\n\na、nginx 判断访问的文件以 .php 结尾\n\nb、nginx 将 /php/1.php 这个路径传给 PHP 的9000端口\n\nc、PHP接收到nginx传过来的路径，就在本机中读取这个文件并运行\n\nd、PHP将运行结果返回给 nginx\n\ne、NGINX将结果返回给用户\n\n\n\n## 两个问题\n\nlnmp环境搭建好了，但是还有些问题需要考虑\n\n1、为PHP容器中安装扩展\n\n我们使用的是 PHP 默认的镜像，这个镜像中缺少很多必要的 PHP 扩展，比如 gd、redis、pdo_mysql 等，这些扩展都需要单独安装。\n\n不过官方提供了安装扩展的两种方法：\n\n​\t核心扩展（pdo_mysql,gd等） 使用 docker-php-ext-install\n\n如安装 gd 库：(先进入PHP容器，然后执行以下命令)\n\n~~~\ndocker-php-ext-install gd\n~~~\n\n​\t\n\n​\t其它扩展（redis、yaf、swoole等）使用 pecl\n\n如安装 redis：(先进入PHP容器，然后执行以下命令)\n\n~~~\npecl install redis\ndocker-php-ext-enable redis\n~~~\n\n\n\n2、把两个容器代码的目录都绑定到一个目录中\n\n现在我们需要把静态页保存到 nginx 容器中，然后把 php 脚本写到 php 容器中，这样在放代码时比较麻烦，所以我们可以将两个服务器的代码目录都绑定到本机，这样直接在本机就可以编写代码了。\n\na、在本机创建一代码目录\n\nb、删除nginx容器重新创建一个新的容器\n\n~~~\ndocker run --name nginx -d -p 8988:80 -v 本地目录:/usr/share/nginx/html --link phpfpm7.2:php nginx:1.15.7-alpine\n~~~\n\n通过 -v 我们就把 nginx 中网站根目录绑定球果一地的目录 中了。\n\n创建 nginx 容器之后，重新向前面一样修改一下 `/etc/nginx/conf.d/default.conf` 配置文件，然后重新启动即可。\n\nc、删除PHP容器然后重新创建一个新的容器\n\n~~~\ndocker run --name phpfpm7.2 -d -v 本地目录:/php --link mysql001:mysql php:7.2-fpm-alpine\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["docker"],"categories":["容器"]},{"title":"php面试题","url":"/2018/12/19/php面试题/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n最近一直在准备面试 整理了一些面试题\n<!-- more -->\n\n\n### 前后端数据交互\nform表单：通过form表单以get/post方式提交数据（最原始） \n         缺点：在提交的时候可能会导致页面跳转或刷新 用户体验不好\n           　　　 单项提交 不知道后台会给出什么响应\n ajax：核心是依赖浏览器提供的XHLHttpRequest对象向服务器发送请求和解析服务器响应提供了流畅的接口，浏览器可以发出HTTP请求和接收HTTP响应\n\n```\n<script>\n\tvar xhr = new XHLHttpRequest()   //创建一个对象\n\txhr.open('GET','/helloAjax',false) // 设置ajax.open()方法里面的三个参数分别为：发送请求的方式，请求的url，是否异步发送请求的布尔值\n\txhr.send()  //发送请求\n\tvar data = xhr.responseText  //当请求到来时 读取数据\n\tconsole.log(data)\n</script>\n```\n\n\n\n\n### php的魔术方法\n* __construct\n- __set()\n- __isset()\n- __unset()\n- __clone() \n- __sleep()\n\n### php处理数组的函数\n- array() 　　　　　　　　创建工资\n- in_array() 　　　　　　 判断元素是否存在数组中\n- array_merge() 　　　　 合并数组\n- count() 　　　　　　　　返回数组中元素的个数\n- array_keys() 　　　　　获取数组的key\n- array_values() 　　　　获取数组中的value\n\n### php处理字符串的函数\n- trim()　　　　　　移除字符串两侧的空白\n- strlen()　　　　　获取字符串的长度\n- substr()　　　　　截取字符串的一部分\n- strstr()　　　　　找到字符串首字母出现的位置\n\n### 数据库的三大范式\n第一范式：（1NF）数据表中的每一列都必须是不可拆分的最小单元，确保每一列的原子性\n第二范式：（2NF）满足1NF之后，要求表中的所有列都必须依赖于主键，不能有任何一列和主键没有关系\n第三范式：（3NF）满足2NF之后，要求表中的每一列都与主键是直接相关而不是间接相关\n\n### 数据库的五大约束\n   1.primary key:设置主键约束\n   2.unique：设置唯一性约束，不能有重复值\n   3.default: 默认值约束\n   4.not null: 设置非空约束，该字段不能为空\n   5.foreign key:设置外键约束\n\n### 消息队列的两种模式\n　　点对点：不可重复消费\n　　发布/订阅：可重复消费\n\n### redis实现消息队列\n　　brpop(消费者)：从队列右侧**弹出**数据 如果队列中没有数据就**堵塞**等待\n　　lpush(生产者)：从队列左侧添加数据\n\n### redis应用场景\n<ol>\n<li>会话缓存（最常用）</li>\n<li>消息队列 　比如：支付</li>\n<li>活动排行榜或计数</li>\n<li>发布，订阅消息</li>\n</ol>\n\n### redis 危险命令\n　　flushall 　　清空所有记录,数据库\n　　flushdb 　　 清空数据库\n　　config 　　　客户端连接后可配置服务器\n　　keys　　　　 客户端链接后可查看所有存在的键\n\n### contet-type 常见格式\n　　text/html\n　　text/plain\n　　text/xml\n　　image/gif\n　　image/jpeg\n　　image/png\n\n​\t\n\n\n\n","tags":["php"],"categories":["后端"]},{"title":"hexo自用黑色主题","url":"/2018/12/17/hexo自用黑色主题/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n关于black-blue模版的相关配置\n<!-- more -->\nhexo和coding打造静态博客 ： \n使用hexo一年有余，对所有主题都感觉有所缺陷，便修改了一个自用黑色主题，本主题以黑色和蓝色为主，色彩鲜明，主题明确。     \n&nbsp;\n## black-blue主题来源\n\n<p>本主题修改自spfk主题，但之前spfk主题有很多问题，本主题改进如下：</p>\n<ol><li>压缩js，css提高性能</li><li>代码段样式显示更完美</li><li>增加本地搜索</li><li>设置更合适的字体大小</li><li>颜色以黑色和蓝色为主，色彩鲜明</li><li>seo适当优化</li><li>删除多说，有言，增加畅言评论</li><li>删除stylus，全部改用css方便修改</li>\n</ol>\n\n## 主题地址\n[black-blue](https://github.com/liudiediea/black-blue)\n\n## black-blue主题配置\n### 切换主题\n复制主题到themes目录下 `cd themed && clone https://github.com/liudiediea/black-blue`，修改_config.yml文件 `theme:black-blue`\n\n\n","tags":["hexo"],"categories":["开发工具"]},{"title":"VUE前端面试题","url":"/2018/12/14/前端面试题/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n面了一家前端 面试前做一些准备\n<!-- more -->\n\n### 1.active-class是哪个组件的属性?嵌套路由怎么定义\n答：vue-router模板的router-link组件\n### 2、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？ \n答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id\n\n### 3、vue-router有哪几种导航钩子？    \n答：三种，一种是全局导航钩子：router.beforeEach(to,from,next) 作用：跳转前进行判断拦截。\n第二种：组件内的钩子；\n第三种：单独路由独享组件\n\n### 6、v-model是什么？怎么使用？ vue中标签怎么绑定事件？\n\n答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性\n绑定事件：`<input @click=doLog() />`\n\n### 10、vuex是什么？怎么使用？哪种功能场景使用它？\n\n答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export\n场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\n### 11、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\n\n答：一个model+view+viewModel框架，数据模型model，viewModel连接两个\n区别：vue数据驱动，通过数据来显示视图层而不是节点操作。\n场景：数据操作比较多的场景，更加便捷\n\n### 12.什么是css hack\n\n<p>因为不同的浏览器对css解析认识不同，会导致页面效果不一样，css hack是通过在css样式上加上一写特殊的符号 让不同的浏览器识别不同的符号</p>\nCSS Hack常见的三种形式：\ncss属性Hack：比如IE6能识别`\"_\"` 和 `\"*\"` ，IE7能识别 `\"*\"` 但是不能识别 `\"_\" `\ncss选择符Hack: 比如IE6能识别`*`html .class{}，IE7能识别`*`+html .class{}\nIE条件注释Hack:只有在IE浏览器才能执行\n\n\n\n\n\n\n\n\n\n","tags":["vue"],"categories":["web"]}]